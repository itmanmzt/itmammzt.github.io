---
layout: post
#标题配置
title: 阻塞和非阻塞 | 同步和异步
#时间配置
date:   2019-08-11 13:24:00 +0800
#大类配置
categories: 多线程


---

* content
{:toc}
---
---

# Blocking & non-blocking | Synchronous & asynchronous

## 阻塞和非阻塞
在发起读取文件的请求时，应用层会调用系统内核的 I/O 接口。<br><br>

如果应用层调用的是阻塞型 I/O，那么在调用之后，应用层即刻被挂起，一直出于等待数据返回的状态，直到系统内核从磁盘读取完数据并返回给应用层，应用层才用获得的数据进行接下来的其他操作。<br><br>

如果应用层调用的是非阻塞 I/O，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。（至于文件内容数据如何返回给应用层，这已经超出了阻塞和非阻塞的辨别范畴。）<br><br>

这便是（脱离同步和异步来说之后）阻塞和非阻塞的区别。总结来说，是否是阻塞还是非阻塞，关注的是接口调用（发出请求）后等待数据返回时的状态。被挂起无法执行其他操作的则是阻塞型的，可以被立即「抽离」去完成其他「任务」的则是非阻塞型的。 <br><br>

![](https://itmanmzt.github.io/styles/images/blocking/001.jpg){:align="center"}<br><br>

## 同步和异步
阻塞和非阻塞解决了应用层等待数据返回时的状态问题，那系统内核获取到的数据到底如何返回给应用层呢？这里不同类型的操作便体现的是同步和异步的区别。 <br><br>

对于同步型的调用，应用层需要自己去向系统内核问询，如果数据还未读取完毕，那此时读取文件的任务还未完成，应用层根据其阻塞和非阻塞的划分，或挂起或去做其他事情（所以同步和异步并不决定其等待数据返回时的状态）；如果数据已经读取完毕，那此时系统内核将数据返回给应用层，应用层即可以用取得的数据做其他相关的事情。 <br><br>

而对于异步型的调用，应用层无需主动向系统内核问询，在系统内核读取完文件数据之后，会主动通知应用层数据已经读取完毕，此时应用层即可以接收系统内核返回过来的数据，再做其他事情。 <br><br>

这便是（脱离阻塞和非阻塞来说之后）同步和异步的区别。也就是说，是否是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。  <br><br>

![](https://itmanmzt.github.io/styles/images/blocking/002.jpg){:align="center"}<br><br>

## 5种IO模型
IO (Input/Output，输入/输出)即数据的读取（接收）或写入（发送）操作，通常用户进程中的一个完整IO分为两阶段：用户进程空间<-->内核空间、内核空间<-->设备空间（磁盘、网络等）。IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。<br><br>
LINUX中进程无法直接操作I/O设备，其必须通过系统调用请求kernel来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。<br><br>
对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。<br><br>
所以，对于一个网络输入操作通常包括两个不同阶段：<br><br>
(1）等待网络数据到达网卡→读取到内核缓冲区，数据准备好；<br>
(2）从内核缓冲区复制数据到进程空间。<br><br>

《UNIX网络编程》说得很清楚，5种IO模型分别是阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型、异步IO模型；前4种为同步IO操作，只有异步IO模型是异步IO操作。下面这样些图，是它里面给出的例子：接收网络UDP数据的流程在IO模型下的分析，在它的基础上再加以简单描述，以区分这些IO模型。
<br><br>
### 阻塞IO模型
![](https://itmanmzt.github.io/styles/images/blocking/003.jpg){:align="center"}<br><br>
 进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。<br><br>
 
 典型应用：阻塞socket、Java BIO；<br><br>
 
 特点：<br>

1、进程阻塞挂起不消耗CPU资源，及时响应每个操作；<br>

2、实现难度低、开发应用较容易；<br>

3、适用并发量小的网络应用开发；<br><br>

不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。<br><br>

### 非阻塞IO模型
![](https://itmanmzt.github.io/styles/images/blocking/004.jpg){:align="center"}<br><br>

 进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。<br><br>
 
 典型应用：socket是非阻塞的方式（设置为NONBLOCK）<br><br>
 
 特点：<br>

1、进程轮询（重复）调用，消耗CPU的资源；<br>

2、实现难度低、开发应用相对阻塞IO模式较难；<br>

3、适用并发量较小、且不需要及时响应的网络应用开发；<br><br>

### IO复用模型
![](https://itmanmzt.github.io/styles/images/blocking/005.jpg){:align="center"}<br><br>

多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。<br><br>

典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;Java NIO;<br><br>

特点：<br>

1、专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;<br>

2、实现、开发应用难度较大；<br>

3、适用高并发服务应用开发：一个进程（线程）响应多个请求；<br><br>

Linux中IO复用的实现方式主要有select、poll和epoll：<br>

Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE；<br>

Poll：原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降；<br>

Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持；<br><br>

### 信号驱动IO模型
![](https://itmanmzt.github.io/styles/images/blocking/006.jpg){:align="center"}<br><br>

 当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。<br><br>
 
特点：回调机制，实现、开发应用难度大；<br><br>

### 异步IO模型
![](https://itmanmzt.github.io/styles/images/blocking/007.jpg){:align="center"}<br><br>

当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。<br><br>

典型应用：JAVA7 AIO、高性能服务器应用<br><br>

特点：<br>

1、不阻塞，数据一步到位；Proactor模式；<br>

2、需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；<br>

3、实现、开发应用难度大；<br>

4、非常适合高性能高并发应用；<br><br>

<br>

<br>

<center>有Marin的地方就有你的收获</center>
